/* 
   Author List:
   R. Stroili, University of Padova  - original author
   E. Feltresi, University of Padova 
   G. Simi, University of Padova, March 2011.
   
   this function computes signal pulse height distribution (spectrum) 
   for a SiPM, taking into account the cross talk probabilty.
   fitf has a single gaussian model
   fitf_g2 has a double gaussian model

*/
   
#include "TMath.h"
#include <iostream>

#include "spectrfitf.h"

Double_t fitf(Double_t* x, Double_t* par) {
  /*===========================================================
         par[0]  ->   Poisson average N
         par[1]  ->   1 p.e. ADC separation
         par[2]  ->   gain RMS contribution
         par[3]  ->   N=0 ADC offset
         par[4]  ->   sigma noise fabs(vecxp.at(1)-vecxp.at(0))
         par[5]  ->   Absolute count normalisation
	 par[6]  ->   Cross talk probability (ref. http://www.gap-optique.unige.ch/Publications/PDF/SiPM-OPticsExpress.pdf)
	 par[7]  ->   Eff
	 par[8]  ->   bin width, needed for normalization
  =============================================================*/

  int maxN=10, minN=0; //min and max number of p.e.

  Double_t ci = 0;
  const Double_t gausfac  = 0.398942;

  Double_t npe = par[0];
  Double_t gain = par[1];
  Double_t grms = par[2];
  Double_t ped = par[3];
  Double_t noise = par[4];
  Double_t ln_norm = par[5];
  Double_t pct  = par[6];
  Double_t eff  = par[7];
  Double_t bw=par[8];
  Double_t probarr[maxN];
  bool debug=false;

  if (debug)  printf ("%f %f %f %f %f %f\n",npe,gain,grms,ped,noise,ln_norm);

  for (int i=0; i<maxN; i++) {
    if (i==0) {
	    ci = exp(-npe);
    } else {
      ci = ci*npe/((float)i);
    }

    if (debug)     printf("    ci = %f ",ci);
    if (i>=minN) {
      /* 
	 probarr[i] is the recursive probability  of generating 
	 i photoelectrons, taking into account the primary p.e. and
	 those generated by cross talk
	 
      */
      double pi=ci*pow(1-pct,i);
      for (int k=1;2*k<i+1;k++){
	pi+=probarr[i-k]*pow(1-pct,i-2*k)*pow(pct,k)*TMath::Binomial(i-k,k);
      }
      probarr[i]=pi;
    }//if (i>=nmin)
    else {probarr[i]=0;}
  }//for (i=0; i<maxN)
  
  Double_t val=0;
  for (int i=minN; i<maxN; i++) {
    Double_t sigma = sqrt(noise*noise+float(i)*grms*grms);
    Double_t xm = ped + float(i)*gain;

    if (debug)     printf (" sigma = %f, noise = %f, xm = %f, grms = %f\n",sigma,noise,xm,grms);

	/* 
	   val is the distribution of the signal amplitudes
	   obtained as the sum of gaussian functions with mean proportional to 
	   the number of p.e. and probability computed above
         	*/
        val += eff * probarr[i] * exp(-0.5*((*x-xm)*(*x-xm))/sigma/sigma)*gausfac/sigma;
  }
  
  return val*exp(ln_norm)*bw;
}




/* OLD MODELS 
  Double_t cipre =0, ciprepre=0, cipreprepre=0;
  Double_t* ciarr = new Double_t[maxN];;
      int fitmodel=4;

      case  1 :{
	//        double cict = (ci+cipre*(i-1)*pct + ciprepre*(i-1)*(i-2)*pct*pct 
	//		       + cipreprepre*(i-1)*(i-2)*(i-3)*pct*pct*pct) 
        double cict = (ci*pow(1-pct,i) +
		       cipre*(i-1)*pct*pow(1-pct,i-2) +
		       ciprepre*(i-2)*(i-3)*pct*pct*pow(1-pct,i-4) +
		       cipreprepre*(i-3)*(i-4)*(i-5)*pct*pct*pct*pow(1-pct,i-6)) 
// 	  / (1 +
// 	     i *             pct *         pow(1-pct,i-1  ) +
// 	     i*(i+1) *       pct*pct *     pow(1-pct,2*i-1) +
// 	     i*(i+1)*(i+2) * pct*pct*pct * pow(1-pct,3*i  ) ); //modified cross talk model
	  / (2-pow(1-pct,i));
        val = val + eff * cict * exp(-0.5*((*x-xm)*(*x-xm))/sigma/sigma)*gausfac/sigma;
	cipreprepre = ciprepre;
	ciprepre=cipre;
	cipre=ci;
	break;
      }//case 1
      case 2 :{
	// [simi, 10/sept/2010]
	// ** exact cross talk model **
	// abandoned, it was based on the wrong assumption that
	// the cross talk photoelectron is generated by the poisson 
	// distribution, instead it should be based on the
	//recursiveprobability to generated i photoelectrons
	double cict=ci*pow(1-pct,i);
	if (debug) cout<<"i="<<i<<"; pct="<<pct<<"; ci="<<ci<<";";
	for (int k=1; 2*k<i+1;k++){
	  cict+=ciarr[i-k]*
	    pow(pct,k)*pow(1-pct,i-2*k)*
	    TMath::Factorial(i-k)/TMath::Factorial(i-2*k);
	  if (debug) cout<<"; k="<<k<<"; ciarr[i-k]"<<ciarr[i-k]<<"; cict="<<cict;
	}
	cict /= (2-pow(1-pct,i));
	if (debug) cout<<endl;
        val = val + eff * cict * exp(-0.5*((*x-xm)*(*x-xm))/sigma/sigma)*gausfac/sigma;
	//ciarr[i]=cict;
	ciarr[i]=ci;
	break;
      }//case 2
      case 3:{
	ciarr[i]=ci;
	double cict=ciarr[i]*pow(1-pct,i);
	for (int k=1; 2*k<i+1; k++){
	  //double binomial = TMath::Factorial(i-k)/TMath::Factorial(i-2*k)/TMath::Factorial(k);
	  double binomial = TMath::Binomial(i-k,k);
	  cict+=ciarr[i-k]*pow(pct,k)*pow(1-pct,i-2*k)*binomial;
	}
        val = val + eff * cict * exp(-0.5*((*x-xm)*(*x-xm))/sigma/sigma)*gausfac/sigma;
	break;
      }//case 3 


 */


Double_t fitf_g2(Double_t* x, Double_t* par) {
  /*===========================================================
         par[0]  ->   Poisson average N
         par[1]  ->   1 p.e. ADC separation
         par[2]  ->   gain RMS contribution
         par[3]  ->   N=0 ADC offset
         par[4]  ->   sigma noise fabs(vecxp.at(1)-vecxp.at(0))
         par[5]  ->   Absolute count normalisation
	 par[6]  ->   Cross talk probability (ref. http://www.gap-optique.unige.ch/Publications/PDF/SiPM-OPticsExpress.pdf)
	 par[7]  ->   Second Gauss.  probability
	 par[8]  ->   Second Gauss.  offset
	 par[9]  ->   Second Gauss.  sigma
	 par[10]  ->   Eff
	 par[11]  ->   bin width, needed for normalization
  =============================================================*/

  int maxN=10, minN=0; //min and max number of p.e.

  Double_t ci = 0;
  const Double_t gausfac  = 0.398942;

  Double_t npe = par[0];
  Double_t gain = par[1];
  Double_t grms = par[2];
  Double_t ped = par[3];
  Double_t noise = par[4];
  Double_t ln_norm = par[5];
  Double_t pct  = par[6];
  Double_t g2p  =par[7];
  Double_t g2off  =par[8];
  Double_t g2sigma =par[9];
  Double_t eff  = par[10];
  Double_t bw=par[11];
  Double_t probarr[maxN];;
  bool debug=false;

  if (debug)  printf ("%f %f %f %f %f %f\n",npe,gain,grms,ped,noise,ln_norm);

  for (int i=0; i<maxN; i++) {
    if (i==0) {
	    ci = exp(-npe);
    } else {
      ci = ci*npe/((float)i);
    }

    if (debug)        printf("    ci = %f ",ci);  
    if (i>=minN) {
      /* 
	 probarr[i] is the recursive probability  of generating 
	 i photoelectrons, taking into account the primary p.e. and
	 those generated by cross talk
	 
      */
      double pi=ci*pow(1-pct,i);
      for (int k=1;2*k<i+1;k++){
	pi+=probarr[i-k]*pow(1-pct,i-2*k)*pow(pct,k)*TMath::Binomial(i-k,k);
      }
      probarr[i]=pi;
    }//if (i>=nmin)
    else {probarr[i]=0;}
  }//for (i=0; i<maxN)


  Double_t val=0;
  for (int i=minN; i<maxN; i++) {
    Double_t sigma = sqrt(noise*noise+float(i)*grms*grms);
    Double_t xm = ped + float(i)*gain;

    if (debug)         printf (" sigma = %f, noise = %f, xm = %f, grms = %f\n",sigma,noise,xm,grms);

	/* 
	   val is the distribution of the signal amplitudes
	   obtained as the sum of gaussian functions with mean proportional to 
	   the number of p.e. and probability computed above
	*/
    //distribution function for i photons (does not include afterpulse)
    Double_t iPhotonsFunc = 
      (1-g2p)*exp(-0.5*((*x-xm)*(*x-xm))/sigma/sigma)*gausfac/sigma
      +g2p*exp(-0.5*((*x-xm-g2off)*(*x-xm-g2off))/g2sigma/g2sigma)*gausfac/g2sigma;

    val += eff * probarr[i] * iPhotonsFunc;
  }
  
  return val*exp(ln_norm)*bw;
}
