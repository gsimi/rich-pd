/*
  Gabriele Simi, University of Padova, 2011

  A macro to extract a spectrum from a thscan of a SiPM,
  compute initial parameters for the fit function
  and fit.
  
  depends on spectrfitf.cc and thscan.C

*/


#include <algorithm>
#include <fstream> 
#include "waveforms.C"
#include "TCanvas.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TSpectrum.h"
#include "TF1.h"
#include "TROOT.h"
#include "TStyle.h"
#include "TSystem.h"
#include "TPaveText.h"
#include "spectrfitf.cc"
#include "test.cc"
#include "TLegend.h"
#include "TGraphErrors.h"

using namespace std;

/*
  function to perform the fit of the pulse height spectrum
  generated by the PMT. 
  It expects at least one peak in the distribution.
  
  fmin,fmax are the fraction of the histogram range to be used in the fit,
  they should be tuned to avoid large regions without data

  Initial values of the fit  parameters are estimated from 
  norm: integral of h between binmin and binmax
  gain=rms**2/mean
  npe=mean**2/rms**2
  offset=xpeak[0]
  noise=gain/pow(gain,./(2*ndynodes))~gain/2;
  fgain1 = k* pow(HV*2.3/13,alpha); 
  fgain1 is the gain of the first dynode, and is used to account for conversions on the first dynode.
  the gain depends on the HV, 2.3 is the fraction of voltage across the first dynode f1=voltage_1/voltage_3, 
  13 is the normalization sum_i (voltage_i/voltage_3)

  if npeaks==1 and forcesignal==false the fit is performed without the signal component
  iff forcesiganl==1 the fit is performed with signal even if only one peak was found. In the latter case
  the conversion on the first dynode is removed from the fit to simplify the function.
  
  
*/
TF1*
fitscan(TH1F* h, double fmin=0, double fmax=1, double HV=950, bool forcesignal=false){
  double bw=h->GetBinWidth(1);
  int dim=h->GetNbinsX();
  double xmin=h->GetXaxis()->GetXmin();
  double xmax=h->GetXaxis()->GetXmax();  
  for (int i=0;i<dim;i++){
    double ni=h->GetBinContent(i);
    if (ni>1e-5) {
      xmin=h->GetBinCenter(i);
      break;
    }
  }
  for (int i=dim;i>0;i--){
    double ni=h->GetBinContent(i);
    if (ni>1e-5) {
      xmax=h->GetBinCenter(i);
      break;
    }
  }
  
  //compute the initial estimate for norm
  double norm=0; 
  int binmin=int(fmin*dim); int binmax=int(fmax*dim)-1;
  if (binmax>dim-1) {cout<<"max out of range"<<endl; return 0;}
  norm=h->Integral(binmin,binmax);
  cout<<"norm "<<norm<<endl;

  //compute the initial estimates for gain,offset,npe,noise

  //Search for peaks to compute initial values
  //note: *** should search within fit limits ***

  double rms=h->GetRMS(), mean=h->GetMean();
  double gain=rms*rms/mean,offset=0,noise=gain/pow(1e6,1./24),npe=mean*mean/rms/rms;

  TSpectrum pf;
  pf.Search(h,8,"nobackground",1e-3); //used to configure the fit
  pf.Print("V");
  const int npeaks=pf.GetNPeaks(); 
  printf("npeaks = %d\n",npeaks);
  float xpeak[npeaks];  for (int i=0;i<npeaks;i++) xpeak[i]=pf.GetPositionX()[i];
  sort(xpeak,xpeak+npeaks-1);
  if (npeaks>0) offset=xpeak[0];
  else offset=0;

  //compute the secondary emission coefficient
  //of the first dynode to account for signals from
  // photoelectric conversions on the 1st dynote

  double k=0.122; //estimated from fit of gain vs HV of pixel 20
  double alpha=0.75;//estimated from pixel 20, usually alpha=3/2
  double fgain1 = k* pow(HV*2.3/13,alpha); //2.3 is the f1=voltage_1/voltage_3, 13is the sum_i (voltage_i/voltage_3)
  //  double rescaling=0.30; //completely ad hoc rescaling
  //  double fgain1=k*pow(v1,alpha)/rescaling; //secondary emission coefficient for fist dynode
  
  //secondary emission coefficient for fist dynode obtained from voltage divider configuration  
  // double k=pow(1e6,1./12)/pow(1000/13,alpha)/pow(2.3*1.2*0.5,alpha/12);
  // double fgain1=k*pow(2.3/13*HV,alpha)
  
  printf("gain = %2.2f\n",gain);
  printf("offset = %2.2f\n",offset);
  printf("npe = %2.2f\n",npe);
  printf("noise = %2.2f\n",noise);
  printf("fgain1 = %2.2f\n",fgain1);

  //now setup the fit function
  gROOT->ProcessLine(".L ../analysis/spectrfitf.cc+");
  gROOT->ProcessLine(".L ./test.cc+");
  int fitmodel=5; //1=fitf, 2=fitf_g2 double gaussian model, 3=pmtfit, 4=pmtfit2, 5=bessel function
  int npar; TF1* f;
  

  switch (fitmodel){

  case 1:
    npar=9;  
    f=new TF1("spectrfit",fitf,xmin,xmax,npar);
    f->SetParNames( "npe","gain","gNoise","offset","iNoise","ln_norm","ct");//,"eff","bw");
    f->SetParameters(npe,  gain,  noise,  offset,    noise/10,   log(norm),0.03);
    f->SetParLimits(2,bw/5,   4*gain); //gnoise
    f->FixParameter(6,0);//ct fixed
    f->FixParameter(7,1);//eff 
    f->FixParameter(8,bw);//bw
    break;

  case 2:
    npar=12; 
    f=new TF1("spectrfit",fitf_g2,xmin,xmax,npar);
    f->SetParNames(  "npe","gain","gNoise","offset","iNoise","ln_norm","ct","g2p","g2off","g2sigma");//,"eff","bw");    break;
    f->SetParameters(npe,gain     ,noise  ,offset       ,noise/10     ,log(norm)  ,0.03, 0.1, gain/5,2/5*noise);
    f->SetParLimits(2,bw/5,   4*gain); //gnoise
    f->FixParameter(6,0);//ct fixed
    f->SetParLimits(7,0,0.9);//g2p
    //  f->FixParameter(7,0);
    f->SetParLimits(8,0,gain);//g2off
    //  f->FixParameter(8,0);
    f->SetParLimits(9,bw/5,50*bw);//g2sigma
    //  f->FixParameter(9,bw);
    f->FixParameter(10,1);//eff 
    f->FixParameter(11,bw);//bw
    break;
  
  default:
  case 3:
    npar=11;  
    f=new TF1("spectrfit",pmtfit,xmin,xmax,npar);
    f->SetParNames( "npe","gain","gNoise","offset","iNoise","norm","fgain1","npe1",  "frac");//,"eff","bw");
    f->SetParameters(npe,  gain,  noise,   offset,  noise/10,   norm, fgain1, npe/2, 0.05);//
    f->SetParLimits(2,bw/5,   4*gain); //gnoise
    f->FixParameter(6,fgain1);//fgain1
    //f->SetParLimits(6,0.1*fgain1,5*fgain1);//fgain1 releasing fgain1 tends to give unphysically high fgain1 values

    f->SetParLimits(7,0.0,4*npe+1);//npe1
    f->SetParLimits(8, 0,  1);//frac
    if (npeaks==1) { //distribution with only noise
      f->FixParameter(7,0.01);//npe1
      f->FixParameter(8,0);//frac
    }
    f->FixParameter(9,1);//eff 
    f->FixParameter(10,bw);//bw
    break;

  case 4:
    npar=11;  
    f=new TF1("spectrfit",pmtfit2,xmin,xmax,npar);
    f->SetParNames( "npe","gain","gNoise","offset","iNoise","ln_norm","ct","P","f");//,"eff","bw");
    f->SetParameters(npe,  gain,  noise,  offset,   noise/10,   log(norm),0.0);//,0.1,0.3 );
    f->SetParLimits(2,bw/5,   4*gain); //gnoise
    f->FixParameter(6,0);//ct fixed
    f->SetParLimits(7,0,1);
    f->SetParLimits(8,0,1);
    f->FixParameter(9,1);//eff 
    f->FixParameter(10,bw);//bw
    break;

  case 5:
    npar=11;
    f=new TF1("spectrfit",pmtpdf1,xmin,xmax,npar);
    f->SetParNames( "npe","gain","dummy","offset","iNoise","norm","fgain1","npe1",  "frac");//,"eff","bw");
    f->SetParameters(npe,  gain,  noise,  offset,  noise/10,norm,  fgain1,  npe/2,   0.05);//
    f->FixParameter(2,0);//dummy paramter
    f->FixParameter(6,fgain1);//fgain1
    //f->SetParLimits(6,0.5*fgain1,1.5*fgain1);//fgain1

    f->SetParLimits(7,0.0,4*npe+1);//npe1
    f->SetParLimits(8, 0,  1);//frac
    if (npeaks==1) { 
      f->FixParameter(7,0.01);//npe1
      f->FixParameter(8,0);//frac
    }
    f->FixParameter(9,1);//eff 
    f->FixParameter(10,bw);//bw
    break;

  }

  f->SetNpx(1000);
  f->SetParLimits(0,0,      5*npe); //npe
  f->SetParLimits(1,bw,     10*gain); //gain
  if (npeaks==1 && forcesignal==false) { 
    f->FixParameter(0,0.01);
    f->FixParameter(1,0); 
    f->FixParameter(2,bw);
  }
  f->SetParLimits(3,-100*bw,100*bw);//offset
  f->SetParLimits(4,bw/50,  2*noise);//inoise
  f->SetParLimits(5,norm*0.1 , norm*1.1);//norm
   
  cout<<"initial fit parameters:"<<endl;
  double pmin,pmax;
  for (int i=0;i<npar;i++){
    f->GetParLimits(i,pmin,pmax);
    printf("%s\t = %.3f \t [%.3f;%.3f]\n",f->GetParName(i),f->GetParameter(i),pmin,pmax);
  }

  //Fit
  cout<<"fitting spectrum in ["<<xmin<<";"<<xmax<<"] ..."<<endl;
  TCanvas * c= new TCanvas("c","c",800,600);
  // c->Divide(2);
  // c->cd(1);
  // f->Draw();
  // c->cd(2);
  h->Fit(f,"EML","",xmin,xmax);
  f->ReleaseParameter(6);
  f->SetParLimits(6,0.5*fgain1,5*fgain1);//fgain1
  h->Fit(f,"EML+","",xmin,xmax);

  cout<<"done"<<endl;

  //Draw
  gStyle->SetOptFit(111);
  h->SetMinimum(0.1);
  cout<<"drawing"<<endl;
  c->SetLogy(1);
  h->Draw("e");
  cout<<"Chi2/NDoF = "<<f->GetChisquare()<<"/"<<f->GetNDF()<<endl;
  return f;
}


double get_voltage(char *fname){
  string sfname(fname);
  size_t pos = sfname.find("px");
  size_t end = sfname.find("V/");
  size_t start = pos+5;
  string svoltage=sfname.substr(start,end-start);
  double voltage = atof(svoltage.c_str());
  if (voltage<500 || voltage > 1100){
    cout<<"invalid file name format, cannot find HV value, forcing HV=950"<<endl;
    voltage=950;
  }
  return voltage;
}

TF1*
fitscan(char* fname, 
	double fmin=0, double fmax=1, bool forcesignal=false){

  // fmin,fmax are the fit limits expressed as fraction of the histogram range



  //get ph distribution
  //TFile::Open(fname);
  TFile *file=new TFile(fname);;
  //  file->cd();
  //  TH1F *h = (TH1F*)gDirectory->Get("ph");
  TCanvas* c1= (TCanvas*)gDirectory->Get("c1");
  TH1F *h = (TH1F*)c1->FindObject("ph");
  double voltage=get_voltage(fname);
 
  return fitscan(h,fmin,fmax,voltage,forcesignal);
}



//Draw contribution of pedestal
TF1*
drawcontribution(TF1 *f){
  Double_t probarr[4];;
  Double_t probarr2[4];;
  TF1 *phe[4];
  TF1 *dyn[4];
  Double_t ci = 0,ci2=0;
    
  Double_t grms = f->GetParameter("gNoise");
  Double_t grms1 = f->GetParameter("gNoise")/f->GetParameter("fgain1")*1.3;
  TLegend *legend=new TLegend(0.6,0.65,0.88,0.85);
  legend->SetTextFont(72);
  legend->SetTextSize(0.02);
  legend->AddEntry(f,"Global Fit","l");
  
  for (int i=0; i<4; i++) {
    if (i==0) {
      ci = exp(-f->GetParameter("npe"));
      ci2 = exp(-f->GetParameter("npe1"));
    } else {
      ci = probarr[i-1]*f->GetParameter("npe")/((float)i);
      ci2 = probarr2[i-1]*f->GetParameter("npe1")/((float)i);
    }
    probarr[i]=ci;
    probarr2[i]=ci2;

    
    Double_t sigma = sqrt(f->GetParameter("iNoise")*f->GetParameter("iNoise")+float(i)*grms*grms);
    Double_t sigma2 = sqrt(f->GetParameter("iNoise")*f->GetParameter("iNoise")+float(i)*grms1*grms1);   
    
    Double_t xm = f->GetParameter("offset") + float(i)*f->GetParameter("gain");
    Double_t xm2 = f->GetParameter("offset") + float(i)*f->GetParameter("gain")/f->GetParameter("fgain1");

    if(i==0){
      //condtribution of pedestal
      phe[0] = new TF1("pedestal","[4]*[3]*((1-[6])*[5]*(0.39894228/[0])*exp(-((x-[1])*(x-[1]))/(2*[0]*[0]))+  [6]*[7]*(0.39894228/[8])*exp(-((x-[9])*(x-[9]))/(2*[8]*[8]))  )",-10,500);
      phe[0]->SetParameter(0,sigma);
      phe[0]->SetParameter(1,xm);
      phe[0]->SetParameter(3,f->GetParameter("norm"));
      phe[0]->SetParameter(4,f->GetParameter(10));//bw
      phe[0]->SetParameter(5,probarr[i]);
      phe[0]->SetParameter(6,f->GetParameter("frac"));
      phe[0]->SetParameter(7,probarr2[i]);
      phe[0]->SetParameter(8,sigma2);
      phe[0]->SetParameter(9,xm2);
      phe[0]->SetLineColor(i+1);
      phe[0]->SetNpx(1000);
      phe[0]->Draw("SAME");

    }else{
    
      //condtribution of 1, 2 and 3 phe
      phe[i] = new TF1("phe","(1-[6])*[4]*[5]*[3]*(0.39894228/[0])*exp(-((x-[1])*(x-[1]))/(2*[0]*[0]))",-10,500);
      phe[i]->SetParameter(0,sigma);
      phe[i]->SetParameter(1,xm);
      phe[i]->SetParameter(3,f->GetParameter("norm"));
      phe[i]->SetParameter(4,f->GetParameter(10));//bw
      phe[i]->SetParameter(5,probarr[i]);
      phe[i]->SetParameter(6,f->GetParameter("frac"));
      phe[i]->SetNpx(1000);
      phe[i]->SetLineColor(i+3);

      phe[i]->Draw("SAME");
    
      //contribution of 1, 2 and 3 phe at 1st dynode
      dyn[i] = new TF1("dyn","[6]*[4]*[5]*[3]*(0.39894228/[0])*exp(-((x-[1])*(x-[1]))/(2*[0]*[0]))",-10,500);
      dyn[i]->SetParameter(0,sigma2);
      dyn[i]->SetParameter(1,xm2);
      dyn[i]->SetParameter(3,f->GetParameter("norm"));
      dyn[i]->SetParameter(4,f->GetParameter(10));//bw
      dyn[i]->SetParameter(5,probarr2[i]);
      dyn[i]->SetParameter(6,f->GetParameter("frac"));
      dyn[i]->SetNpx(1000);

      dyn[i]->SetLineColor(i+8);
      dyn[i]->Draw("SAME");
    }


   //legend->AddEntry(backFcn,"Background fit","l");
   //legend->AddEntry(signalFcn,"Signal fit","l");
  
  }
  legend->AddEntry(phe[0],"pedestal","l");
  legend->AddEntry(phe[1],"one phe","l");
  legend->AddEntry(phe[2],"2 phe","l");
  legend->AddEntry(phe[3],"3 phe","l");
  legend->AddEntry(dyn[1],"one phe at 1st dynode","l");
  legend->AddEntry(dyn[2],"2 phe at 1st dynode","l");


  legend->Draw();
  return f;
}


/* 
   A macro to fit a list of threshold scans in a directory.
 */
/*
double*
mfitscan(char *dir="/data/superb/SiPM/RadHard/Feb2011LNL/"){
  vector<string> flist=GetListOfFiles(dir,"threshold-scan-");
  cout<<"found "<<flist.size()<<" scans to analyze"<<endl;
  return mfitscan(flist);
}
*/
/* fits a list of files passed in flist
   returns an array of double.
   The fitted values for file ifile of parametr jpar is:
   par[ifile,jpar] = pararray[ifile*npars + 2*jpar]
   epar[ifile,jpar] = pararray[ifile*npars + 2*jpar + 1]
*/

double* mfitscan(char * filelist="filelist.txt", char* fitted_data="fitted_data.txt", bool forcesignal=false ){
  ifstream list(filelist);
  vector<string> flist;
  string s;
  //int lines = std::count(std::istreambuf_iterator<char>( file ),std::istreambuf_iterator<char>(), '\n' ); 
  for(int i=0;i<14; i++){
    list>>s;
    flist.push_back("/home/lhcb/rich-pd/pmttest/"+s);
  }
  ofstream out; out.open(fitted_data);
  const int nfiles(flist.size());
  const int npars=11; //this is hardwired, should be possible to extract it from f
  double* parmatrix = new double[nfiles*npars*2];
  for (int ifile=0;ifile<nfiles; ifile++){
    cout<<"\n"<<"file directory : "<<flist[ifile].c_str()<<endl;
    TF1* f=fitscan((char*)flist[ifile].c_str(),5./100,1, forcesignal);
    if (f==0){ cout<<"Error, fit for "<<flist[ifile].c_str()<<
	" not found, skipping"<<endl;
      continue;}
    if (ifile==0){
      out<<"ifile\t"; 
      for(int j=0;j<npars;j++){
	out<<f->GetParName(j)<<"\t"<<"e"<<f->GetParName(j)<<"\t";
      }
      out<<"pxNumber"<<"\t";
      out<<"voltage"<<endl;

    }
    double *fitpar=f->GetParameters();
    double *fiterr=f->GetParErrors();
    out<<ifile<<"\t";
    for (int jpar=0;jpar<npars;jpar++){
      parmatrix[ifile*npars+2*jpar]=fitpar[jpar];
      parmatrix[ifile*npars+2*jpar+1]=fiterr[jpar];
      out<<fitpar[jpar]<<"\t"<<fiterr[jpar]<<"\t";
    }
    //    out<<darkrate(f,flist[ifile].c_str(),gate)<<"\t";
    //    out<<filetime(flist[ifile])<<"\t";
    string pxname;
    string volt;
    string path;
    size_t pos;
    size_t start,end;

    path = flist[ifile].c_str();
    pos = path.find("px");
    pxname = path.substr(pos+2,2);
    out<<pxname<<"\t";

    end = path.find("V/");
    start = pos+5;
    volt = path.substr(start,end-start);
    out<<volt<<endl;

    if (f!=0) delete f;
    
  }
  return parmatrix;
}


/* helper functions to list the contents of a directory */

Bool_t IsItDirectory(const char *name, char * dirfile) 
{
  // Check if name is a directory.
  Long64_t size;
  Long_t id, flags, modtime;

  gSystem->ChangeDirectory(dirfile);
  flags = id = size = modtime = 0;
  gSystem->GetPathInfo(name, &id, &size, &flags, &modtime);
  Int_t isdir = (Int_t)flags & 2;

  return isdir ? kTRUE : kFALSE;
}
 
vector<string> GetListOfFiles(char* dirname, char* match=0){
  string pwd(gSystem->pwd());
  void *dir = gSystem->OpenDirectory(dirname);
  if (!dir) {
    vector<string> empty;
    return  empty;
  }

  const char *file = 0;
  vector<string> contents;
  while ((file = gSystem->GetDirEntry(dir))) {
    if (!( IsItDirectory(file,dirname)) ) {
      string filestr(file);
      if ((match==0) || (filestr.find(match)!=string::npos) ){
	string filepath(dirname);
	filepath.append(file);
	contents.push_back(filepath);
      }
    }
  }
  gSystem->FreeDirectory(dir);
  gSystem->ChangeDirectory(pwd.c_str());
  return contents;
}

/*Plot the datasheet values in a 2D histogram*/

TH2F* datasheet(const char* rdata="datasheet"){
  TH2F *h = new TH2F("datasheet","gain",8,0,7, 8,0,7);
  h->SetXTitle("pixel 1 to 8");
  h->SetYTitle("pixel 1 to 57");
  ifstream file(rdata);
  double  ch;
  cout<<ch<<endl;
  //file>>ch;
  for(int i=1;i<65;i++){
    if (file.eof()) break;
    int x = int(i-1)%8+1;
    int y = int((i-0.001)/8)+1;
    // cout<<" x "<<x<<" y "<<y<<" val "<<value[ipar]<<endl;
    //getline(file,ch);
    file>>ch;
    h->SetBinContent(x,y,ch);
  }
  h->Draw("colz");
  return h;
}


/*Fonction takes fitted values to plot it in a 2D histogram*/

TH2F* uniformity(const char* rdata="test.dat", int ipar=3, int normpx=61){



  const int npar(25);
  if(ipar>=npar){return 0;}
  ifstream file(rdata);
  string  ch;
  string parname[npar];
  for(int i=0; i<npar;i++){
    file>>parname[i];
  }
  const char * title=parname[ipar].c_str();
  //sprintf(var,"gain",ipar);
  TH2F *h = new TH2F("uniformity",title,8,0,7, 8,0,7);
  h->SetXTitle("pixel 1 to 8");
  h->SetYTitle("pixel 1 to 57");
  double value[npar];
  double normvalue=100;
  while(!file.eof()){
    for (int i=0;i<npar;i++) {
      file>>value[i];
      if (file.eof()) break;
    }
    if (file.eof()) break;
    float pixel=value[23];
    int x = int(pixel-1)%8+1;
    int y = int((pixel-0.001)/8)+1;
    if(int(pixel+0.0001)==normpx){
      normvalue=value[ipar];
    }
    // cout<<" x "<<x<<" y "<<y<<" val "<<value[ipar]<<endl;
    h->SetBinContent(x,y,value[ipar]);
  }
  h->Scale(100./normvalue);
  h->SetStats(0);
  h->Draw("colz");
  TPaveText *pt=new TPaveText(0.7,0.85,0.98,0.98,"brNDC");
  char  legend1[100] ;
  char c1[20];
  sprintf(c1,"%d",normpx);
  strcpy(legend1,"normpx : ");
  strcat(legend1,c1);
  pt->AddText(legend1);
  char  legend2[100] ;
  char c2[100];
  sprintf(c2,"%f",normvalue);
  strcpy(legend2,"value for normpx : ");
  strcat(legend2,c2);
  pt->AddText(legend2);
  pt->Draw();
  return h;
}




//fit function for the gain VS high voltage
Double_t gainfit(Double_t* x, Double_t* par) {
  /*===========================================================
   *x       -> voltage in kV
    par[0]  ->   proportional constant
    par[1]  ->   exponent paramenter
    par[2]  ->   number of dynodes

  =============================================================*/
  Double_t c = par[0];
  Double_t alpha = par[1];
  Double_t n= par[2];
  Double_t nalpha = n*alpha;
  return pow(c,n)*pow(*x,nalpha);
}


//Draw the voltage dependency of a parameter and if the parameter is the gain, fit it
TGraphErrors* voltagedependency(const char* rdata="test.dat", int ipar=3){


  Double_t x[20], y[20],ex[20], ey[20];
  int nvalues=14;
  const int npar(25);
  if(ipar>=npar){return 0;}
  ifstream file(rdata);
  string  ch;
  string parname[npar];
  for(int i=0; i<npar;i++){
    file>>parname[i];
  }
  //const char * title=parname[ipar].c_str();
  //sprintf(var,"gain",ipar);
  int j=0;
  double value[npar];
  while(!file.eof()){
    for (int i=0;i<npar;i++) {
      file>>value[i];
      if (file.eof()) break;
    }
    if (file.eof()) break;
    x[j]=value[24]/1e3; //HV in kV
    ex[j]=0;
    y[j]=value[ipar];  //value of the fitted paramter
    if(ipar<npar-1) ey[j]=value[ipar+1];
    else ey[j]=0;

    
    if (ipar == 17){ //special case for probability of signal on 1st dynode)
      double frac=value[ipar];
      double npe=value[1];
      //      double npe1=value[15];
      //      y[j]=1./((1./frac-1)*(1-TMath::Exp(-npe))/(1-TMath::Exp(-npe1)) + 1);
      //      parname[ipar]="1stdynode fraction";
      y[j]=(1.-frac)*(1-TMath::Exp(-npe));// + frac*(1-TMath::Exp(-npe1));
      parname[ipar]="Quantum efficiency";
      
    }
    
    j++;
    // cout<<" x "<<x<<" y "<<y<<" val "<<value[ipar]<<endl;
  }
  TGraphErrors *g = new TGraphErrors(nvalues,x,y,ex,ey);
  const char * title=parname[ipar].c_str();
  g->SetTitle(title);
  g->SetMarkerSize(1.5);
  g->SetMarkerStyle(5);
  g->Draw("LPA");

  if (ipar==3){
    //fit gain depency on voltage
    int nfiles=j;
    TF1* f=new TF1("gainfit",gainfit,x[0],x[nfiles-1],3);
    cout<<"x0 "<<x[0]<<" x1 "<<x[nfiles-1]<<endl;
    f->SetParameter(0,50);
    f->SetParNames("const","alpha","ndynodes");
    f->SetParLimits(0,0,10);
    f->SetParameter(1,0.75);
    f->SetParLimits(1,0,2);
    f->FixParameter(2,12); // fix number of dynodes
    g->Fit(f,"","",x[0],x[nfiles-1]);
    double c= f->GetParameter(0);
    double alpha = f->GetParameter(1); //alpha should be 2./3
    double n = f->GetParameter(2);

    const int ndynodes=12;
    double fHV[ndynodes]={2.3,1.2,1,1,1,1,1,1,1,1,1,0.5}; 
    double fnorm=0; for (int i=0;i<ndynodes;i++){fnorm+=fHV[i];}
    double fproduct=1; for (int i=0;i<ndynodes;i++){fproduct*=fHV[i]/fnorm;}
    double eoveradc=3.5e4;
    //1./1000**alpha takes into account the fact that we use HV in kV
    double k = c*pow(eoveradc,1./n)/pow(fproduct,alpha/n)/pow(1000,alpha);
    cout << " k "<<k<<endl;

    double HV=950;
    double fgain1 = k* pow(HV*2.3/13,alpha);
    cout << " fgain1 "<<fgain1<<endl;
    double fgain2 = k* pow(HV*1.2/13,alpha);
    cout << " fgain2 "<<fgain2<<endl;
    double fgain3 = k* pow(HV/13,alpha);
    cout << " fgain3 "<<fgain3<<endl;
    double fgain12 = k* pow(HV*0.5/13,alpha);
    cout << " fgain12 "<<fgain12<<endl;
  }
  return g;
}



double
computetheoreticalgainrms_1stoverpk(){
  double g[12];
  for (int i=0;i<12;i++){g[i]=3.2;}; 
  g[0]=6; g[1]=3.7; g[11]=1.9; 

  double n[13], en[13];

  cout<<"conversion on photocade"<<endl;
  n[0]=1;en[0]=0;
  for (int i=0;i<12;i++){n[i+1]=n[i]*g[i]; en[i+1]=sqrt(n[i+1]+pow((en[i]*g[i]),2));}

  cout<<"gain:"<<endl;
  for (int i=0;i<12;i++){cout<<g[i]<<":";} cout<<endl;
  cout<<"number of electrons:"<<endl;
  for (int i=0;i<13;i++){cout<<n[i]<<":";} cout<<endl;
  cout<<"elative fluctuation:"<<endl;
  for (int i=0;i<13;i++){cout<<en[i]/n[i]<<":";} cout<<endl;
  double rk=en[12]/n[12];
  cout<<endl;

  cout<<"conversion on first dynode"<<endl;
  cout<<"gain:"<<endl;
  n[1]=1; en[1]=0;
  for (int i=1;i<12;i++){n[i+1]=n[i]*g[i]; en[i+1]=sqrt(n[i+1]+pow((en[i]*g[i]),2));}

  for (int i=1;i<12;i++){cout<<g[i]<<":";} cout<<endl;
  cout<<"number of electrons:"<<endl;
  for (int i=1;i<13;i++){cout<<n[i]<<":";} cout<<endl;
  cout<<"elative fluctuation:"<<endl;
  for (int i=1;i<13;i++){cout<<en[i]/n[i]<<":";} cout<<endl;
  double r1=en[12]/n[12];

  return r1/rk;

}
