/* 
   Author List:
   R. Stroili, University of Padova  - original author
   E. Feltresi, University of Padova 
   G. Simi, University of Padova, March 2011.
   
   this function computes signal pulse height distribution (spectrum) 
   for a SiPM, taking into account the cross talk probabilty.
   fitf has a single gaussian model
   fitf_g2 has a double gaussian model

*/
   
#include "TMath.h"
#include <iostream>

#include "spectrfitf.h"


Double_t pmtfit(Double_t* x, Double_t* par) {
  /*===========================================================
         par[0]  ->   Poisson average N
         par[1]  ->   1 p.e. ADC separation (gain)
         par[2]  ->   gain RMS contribution
         par[3]  ->   N=0 ADC offset
         par[4]  ->   sigma noise fabs(vecxp.at(1)-vecxp.at(0))
         par[5]  ->   Absolute count normalisation
	 par[6]  ->   Fraction of gain on first dynode
	 par[7]  ->   Poisson average 1st dynode
	 par[8]  ->   Probability of interaction on first dynode
	 par[9]  ->   Eff
	 par[10] ->   bin width, needed for normalization

  =============================================================*/
  int maxN=10, minN=0; //min and max number of p.e.

  Double_t ci = 0,ci2=0;
  const Double_t gausfac  = 0.3989422804;

  Double_t mu = par[0];
  Double_t gain = par[1];
  Double_t grms = par[2];
  Double_t ped = par[3];
  Double_t noise = par[4];
  Double_t norm = par[5];//total normalisation coef
  //  Double_t pct  = par[6]; //unused
  Double_t fgain = par[6];
  Double_t mu1 = par[7];
  Double_t gain1=gain*fgain;
  Double_t grms1=grms*fgain;
  Double_t p1dyn = par[8];// proba. 1st dyn.
  Double_t eff  = par[9];
  Double_t bw=par[10];

  Double_t probarr[maxN];;
  Double_t probarr2[maxN];;
  bool debug=false;

  if (debug)  printf ("%f %f %f %f %f %f\n",mu,gain,grms,ped,noise,norm);
  
  for (int i=0; i<maxN; i++) {
    if (i==0) {
      ci = exp(-mu);
      ci2 = exp(-mu1);
    } else {
      ci = ci*mu/((float)i);
      ci2 = ci2*mu1/((float)i);
    }
    
    if (debug)     printf("    ci = %f ",ci);
    if (i>=minN) {
      /* 
   	 probarr[i] is the recursive probability  of generating 
   	 i photoelectrons, taking into account the primary p.e. and
   	 those generated by cross talk
  	 
  	 
   	 double pi=ci*pow(1-pct,i);
   	 double pi2=ci2*pow(1-pct,i);
   	 for (int k=1;2*k<i+1;k++){
   	 pi+=probarr[i-k]*pow(1-pct,i-2*k)*pow(pct,k)*TMath::Binomial(i-k,k);
   	 pi2+=probarr2[i-k]*pow(1-pct,i-2*k)*pow(pct,k)*TMath::Binomial(i-k,k);
   	 }
   	 probarr[i]=pi;
   	 probarr2[i]=pi2;
       */
      probarr[i]=ci;
      probarr2[i]=ci2;
    }//if (i>=nmin)
    else {probarr[i]=0;probarr2[i]=0;}
  }//for (i=0; i<maxN)
  
  /*
  double p=0.25; double N=mu/p; 
  for (int k=0; k<maxN; k++) {
    if (k<=N) 
      probarr[k]=TMath::Binomial(N,k)*pow(p,k)*pow(1-p,N-k);
    else
      probarr[k]=0; 
  }
  */  
  
  Double_t valK=0;
  Double_t val1=0;
  
  for (int i=minN; i<maxN; i++) {
    Double_t sigma = sqrt(noise*noise+float(i)*grms*grms);
    Double_t sigma2 = sqrt(noise*noise+float(i)*grms1*grms1);
    
    Double_t xm = ped + float(i)*gain;
    Double_t xm2 = ped + float(i)*gain1;

    //    if (debug)     printf (" sigma = %f, noise = %f, xm = %f, grms = %f\n",sigma,noise,xm,grms);
    
	/* 
	   val is the distribution of the signal amplitudes
	   obtained as the sum of gaussian functions with mean proportional to 
	   the number of p.e. and probability computed above
	*/
      valK += eff * probarr[i] * exp(-0.5*((*x-xm)*(*x-xm))/sigma/sigma)*gausfac/sigma ;
      val1 += eff* probarr2[i] * exp(-0.5*((*x-xm2)*(*x-xm2))/sigma2/sigma2)*gausfac/sigma2 ;	 
  }
  
  return   norm*((1-p1dyn)*valK+p1dyn*val1)*bw;
}




Double_t pmtfit2(Double_t* x, Double_t* par) {
  /*===========================================================
         par[0]  ->   Poisson average N
         par[1]  ->   1 p.e. ADC separation
         par[2]  ->   gain RMS contribution
         par[3]  ->   N=0 ADC offset
         par[4]  ->   sigma noise fabs(vecxp.at(1)-vecxp.at(0))
         par[5]  ->   Absolute count normalisation
	 par[6]  ->   Cross talk probability (ref. http://www.gap-optique.unige.ch/Publications/PDF/SiPM-OPticsExpress.pdf)
	 par[7]  ->   Poisson average 1st dynode
	 par[8]  ->   gain RMS 1st dynode
	 par[9]  ->   1 p.e 1st dynode ADC separation
	 par[10] ->   Eff
	 par[11] ->   bin width, needed for normalization

  =============================================================*/
  int maxN=10, minN=0; //min and max number of p.e.

  Double_t ci = 0;//,ci2=0;
  const Double_t gausfac  = 0.3989422804;

  Double_t mu = par[0];
  Double_t gain = par[1];
  Double_t grms = par[2];
  Double_t ped = par[3];
  Double_t noise = par[4];
  Double_t ln_norm = par[5];
  Double_t pct  = par[6];
  Double_t P = par[7];
  Double_t f = par[8];
  Double_t eff  = par[9];
  Double_t bw=par[10];

  //  Double_t standdev = par[11];
  //  Double_t frac = par[10];
  Double_t probarr[maxN];;
  // Double_t probarr2[maxN];;
  bool debug=false;

  if (debug)  printf ("%f %f %f %f %f %f\n",mu,gain,grms,ped,noise,ln_norm);

  for (int i=0; i<maxN; i++) {
    if (i==0) {
	    ci = exp(-mu);
	    // ci2 = exp(-mu1);
    } else {
      ci = ci*mu/((float)i);
      // ci2 = ci2*mu2/((float)i);
    }

    if (debug)     printf("    ci = %f ",ci);
    if (i>=minN) {
      /* 
	 probarr[i] is the recursive probability  of generating 
	 i photoelectrons, taking into account the primary p.e. and
	 those generated by cross talk
	 
      */
     double pi=ci*pow(1-pct,i);
     // double pi2=ci2*pow(1-pct,i);
     for (int k=1;2*k<i+1;k++){
	pi+=probarr[i-k]*pow(1-pct,i-2*k)*pow(pct,k)*TMath::Binomial(i-k,k);
	//pi2+=probarr2[i-k]*pow(1-pct,i-2*k)*pow(pct,k)*TMath::Binomial(i-k,k);
      }
      probarr[i]=pi;
      //probarr2[i]=pi2;
    }//if (i>=nmin)
    else {probarr[i]=0;}
  }//for (i=0; i<maxN)
  
  Double_t val=0;
  
  for (int i=minN; i<maxN; i++) {
    Double_t sigma = sqrt(noise*noise+float(i)*grms*grms);
     Double_t sigma2 = sqrt(noise*noise+f*grms*grms);
    
    Double_t xm = ped + float(i)*gain;
    // Double_t xm2 = ped + float(i)*gain2;

    if (debug)     printf (" sigma = %f, noise = %f, xm = %f, grms = %f\n",sigma,noise,xm,grms);
     if (i==0){
       val += eff * probarr[i] *((1-P)* exp(-0.5*((*x-xm)*(*x-xm))/sigma/sigma)*gausfac/sigma + P*(gausfac/(sigma2))*exp(-0.5*((*x-gain*f)*(*x-gain*f))/(sigma2*sigma2)));
       } else{
	/* 
	   val is the distribution of the signal amplitudes
	   obtained as the sum of gaussian functions with mean proportional to 
	   the number of p.e. and probability computed above
	*/
    val += eff * probarr[i] * exp(-0.5*((*x-xm)*(*x-xm))/sigma/sigma)*gausfac/sigma ;
				 } 
  }
  
  return val*exp(ln_norm)*bw;
}



Double_t fitf(Double_t* x, Double_t* par) {
  /*===========================================================
         par[0]  ->   Poisson average N
         par[1]  ->   1 p.e. ADC separation
         par[2]  ->   gain RMS contribution
         par[3]  ->   N=0 ADC offset
         par[4]  ->   sigma noise fabs(vecxp.at(1)-vecxp.at(0))
         par[5]  ->   Absolute count normalisation
	 par[6]  ->   Cross talk probability (ref. http://www.gap-optique.unige.ch/Publications/PDF/SiPM-OPticsExpress.pdf)
	 par[7]  ->   Eff
	 par[8]  ->   bin width, needed for normalization
  =============================================================*/

  int maxN=10, minN=0; //min and max number of p.e.

  Double_t ci = 0;
  const Double_t gausfac  = 0.398942;

  Double_t mu = par[0];
  Double_t gain = par[1];
  Double_t grms = par[2];
  Double_t ped = par[3];
  Double_t noise = par[4];
  Double_t ln_norm = par[5];
  Double_t pct  = par[6];
  Double_t eff  = par[7];
  Double_t bw=par[8];
  Double_t probarr[maxN];
  bool debug=false;

  if (debug)  printf ("%f %f %f %f %f %f\n",mu,gain,grms,ped,noise,ln_norm);

  for (int i=0; i<maxN; i++) {
    if (i==0) {
	    ci = exp(-mu);
    } else {
      ci = ci*mu/((float)i);
    }

    if (debug)     printf("    ci = %f ",ci);
    if (i>=minN) {
      /* 
	 probarr[i] is the recursive probability  of generating 
	 i photoelectrons, taking into account the primary p.e. and
	 those generated by cross talk
	 
      */
      double pi=ci*pow(1-pct,i);
      for (int k=1;2*k<i+1;k++){
	pi+=probarr[i-k]*pow(1-pct,i-2*k)*pow(pct,k)*TMath::Binomial(i-k,k);
      }
      probarr[i]=pi;
    }//if (i>=nmin)
    else {probarr[i]=0;}
  }//for (i=0; i<maxN)
  
  Double_t val=0;
  for (int i=minN; i<maxN; i++) {
    Double_t sigma = sqrt(noise*noise+float(i)*grms*grms);
    Double_t xm = ped + float(i)*gain;

    if (debug)     printf (" sigma = %f, noise = %f, xm = %f, grms = %f\n",sigma,noise,xm,grms);

	/* 
	   val is the distribution of the signal amplitudes
	   obtained as the sum of gaussian functions with mean proportional to 
	   the number of p.e. and probability computed above
         	*/
        val += eff * probarr[i] * exp(-0.5*((*x-xm)*(*x-xm))/sigma/sigma)*gausfac/sigma;
  }
  
  return val*exp(ln_norm)*bw;
}




/* OLD MODELS 
  Double_t cipre =0, ciprepre=0, cipreprepre=0;
  Double_t* ciarr = new Double_t[maxN];;
      int fitmodel=4;

      case  1 :{
	//        double cict = (ci+cipre*(i-1)*pct + ciprepre*(i-1)*(i-2)*pct*pct 
	//		       + cipreprepre*(i-1)*(i-2)*(i-3)*pct*pct*pct) 
        double cict = (ci*pow(1-pct,i) +
		       cipre*(i-1)*pct*pow(1-pct,i-2) +
		       ciprepre*(i-2)*(i-3)*pct*pct*pow(1-pct,i-4) +
		       cipreprepre*(i-3)*(i-4)*(i-5)*pct*pct*pct*pow(1-pct,i-6)) 
// 	  / (1 +
// 	     i *             pct *         pow(1-pct,i-1  ) +
// 	     i*(i+1) *       pct*pct *     pow(1-pct,2*i-1) +
// 	     i*(i+1)*(i+2) * pct*pct*pct * pow(1-pct,3*i  ) ); //modified cross talk model
	  / (2-pow(1-pct,i));
        val = val + eff * cict * exp(-0.5*((*x-xm)*(*x-xm))/sigma/sigma)*gausfac/sigma;
	cipreprepre = ciprepre;
	ciprepre=cipre;
	cipre=ci;
	break;
      }//case 1
      case 2 :{
	// [simi, 10/sept/2010]
	// ** exact cross talk model **
	// abandoned, it was based on the wrong assumption that
	// the cross talk photoelectron is generated by the poisson 
	// distribution, instead it should be based on the
	//recursiveprobability to generated i photoelectrons
	double cict=ci*pow(1-pct,i);
	if (debug) cout<<"i="<<i<<"; pct="<<pct<<"; ci="<<ci<<";";
	for (int k=1; 2*k<i+1;k++){
	  cict+=ciarr[i-k]*
	    pow(pct,k)*pow(1-pct,i-2*k)*
	    TMath::Factorial(i-k)/TMath::Factorial(i-2*k);
	  if (debug) cout<<"; k="<<k<<"; ciarr[i-k]"<<ciarr[i-k]<<"; cict="<<cict;
	}
	cict /= (2-pow(1-pct,i));
	if (debug) cout<<endl;
        val = val + eff * cict * exp(-0.5*((*x-xm)*(*x-xm))/sigma/sigma)*gausfac/sigma;
	//ciarr[i]=cict;
	ciarr[i]=ci;
	break;
      }//case 2
      case 3:{
	ciarr[i]=ci;
	double cict=ciarr[i]*pow(1-pct,i);
	for (int k=1; 2*k<i+1; k++){
	  //double binomial = TMath::Factorial(i-k)/TMath::Factorial(i-2*k)/TMath::Factorial(k);
	  double binomial = TMath::Binomial(i-k,k);
	  cict+=ciarr[i-k]*pow(pct,k)*pow(1-pct,i-2*k)*binomial;
	}
        val = val + eff * cict * exp(-0.5*((*x-xm)*(*x-xm))/sigma/sigma)*gausfac/sigma;
	break;
      }//case 3 


 */


Double_t fitf_g2(Double_t* x, Double_t* par) {
  /*===========================================================
         par[0]  ->   Poisson average N
         par[1]  ->   1 p.e. ADC separation
         par[2]  ->   gain RMS contribution
         par[3]  ->   N=0 ADC offset
         par[4]  ->   sigma noise fabs(vecxp.at(1)-vecxp.at(0))
         par[5]  ->   Absolute count normalisation
	 par[6]  ->   Cross talk probability (ref. http://www.gap-optique.unige.ch/Publications/PDF/SiPM-OPticsExpress.pdf)
	 par[7]  ->   Second Gauss.  probability
	 par[8]  ->   Second Gauss.  offset
	 par[9]  ->   Second Gauss.  sigma
	 par[10]  ->   Eff
	 par[11]  ->   bin width, needed for normalization
  =============================================================*/

  int maxN=10, minN=0; //min and max number of p.e.

  Double_t ci = 0;
  const Double_t gausfac  = 0.398942;

  Double_t mu = par[0];
  Double_t gain = par[1];
  Double_t grms = par[2];
  Double_t ped = par[3];
  Double_t noise = par[4];
  Double_t ln_norm = par[5];
  Double_t pct  = par[6];
  Double_t g2p  =par[7];
  Double_t g2off  =par[8];
  Double_t g2sigma =par[9];
  Double_t eff  = par[10];
  Double_t bw=par[11];
  Double_t probarr[maxN];;
  bool debug=false;

  if (debug)  printf ("%f %f %f %f %f %f\n",mu,gain,grms,ped,noise,ln_norm);

  for (int i=0; i<maxN; i++) {
    if (i==0) {
	    ci = exp(-mu);
    } else {
      ci = ci*mu/((float)i);
    }

    if (debug)        printf("    ci = %f ",ci);  
    if (i>=minN) {
      /* 
	 probarr[i] is the recursive probability  of generating 
	 i photoelectrons, taking into account the primary p.e. and
	 those generated by cross talk
	 
      */
      double pi=ci*pow(1-pct,i);
      for (int k=1;2*k<i+1;k++){
	pi+=probarr[i-k]*pow(1-pct,i-2*k)*pow(pct,k)*TMath::Binomial(i-k,k);
      }
      probarr[i]=pi;
    }//if (i>=nmin)
    else {probarr[i]=0;}
  }//for (i=0; i<maxN)


  Double_t val=0;
  for (int i=minN; i<maxN; i++) {
    Double_t sigma = sqrt(noise*noise+float(i)*grms*grms);
    Double_t xm = ped + float(i)*gain;

    if (debug)         printf (" sigma = %f, noise = %f, xm = %f, grms = %f\n",sigma,noise,xm,grms);

	/* 
	   val is the distribution of the signal amplitudes
	   obtained as the sum of gaussian functions with mean proportional to 
	   the number of p.e. and probability computed above
	*/
    //distribution function for i photons (does not include afterpulse)
    Double_t iPhotonsFunc = 
      (1-g2p)*exp(-0.5*((*x-xm)*(*x-xm))/sigma/sigma)*gausfac/sigma
      +g2p*exp(-0.5*((*x-xm-g2off)*(*x-xm-g2off))/g2sigma/g2sigma)*gausfac/g2sigma;

    val += eff * probarr[i] * iPhotonsFunc;
  }
  
  return val*exp(ln_norm)*bw;
}
